---
title: 分布式系统介绍
tags:

  - 分布式系统
---

### 分布式系统介绍

#### 发展背景

1. 单一应用架构

   当网站流量很小时，只需要一个应用，将所有功能都部署在一起，以减少部署节点和成本。

2. 垂直应用架构

   当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆分成互不相干的几个应用，以提升效率。

3. 分布式微服务架构

   当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快的响应多变的市场需求。

微服务架构偏向于业务，比如可以把微服务按子业务、数据库、接口等维度拆分成不同的微服务。

分布式架构偏向于机器，目前你可以说微服务架构是分布式架构，因为大部分公司都是把每个服务单独部署的。



#### 分布式系统的挑战

##### 分布式session

###### seesion粘滞

​	即粘性seesion、当用户访问集群中某台机器后，强制指定后续所有请求均落在此机器上。

使用场景：机器数适中、对稳定性要求不是非常苛刻

优点：实现简单、配置方便、没有额外网络开销

缺点：网络中有机器Down掉时，用户seesion会丢失、容易造成单点故障

方案：Nginx的ip_hash负载均衡方案



###### seesion复制

​	将一台机器上的seesion数据广播复制到集群中的其余机器上

使用场景：机器较少，网络流量较小

优点：实现简单、配置少、当网络中有机器Down掉时不影响用户访问

缺点：广播式复制到其余机器有一定延时，带来一定网络开销

方案：开源方案tomcat-redis-session-manager，暂不支持Tocat8



###### 缓存集中式管理

​	将session存入分布式缓存集群中的某台机器上，当用户访问不同结点时先从缓存中拿session信息

使用场景：集群中机器数多、网络环境复杂

优点：可靠性好

缺点：实现复杂、稳定性依赖于缓存的稳定性、session信息放入缓存时要有合理的策略写入

方案：开源方案spring session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法



##### 分布式配置中心

​	在分布式系统中，一次构建、发布、上线是一个非常非常重要的过程，它不像单机时代那样重启一台机器、一个进程就可以了，在分布式系统中，它涉及到软件包分发都可能超过几千台机器，然后将几千台机器上的应用进程一一重启，这么一个过程，需要很长时间。

​	那么如何在不停应用集群的情况下，调整整个集群的运行时行为特征，是一个分布式系统必须回答的问题。从这个角度将，我们认为：**每一个大型分布式系统都应该有一个配置中心**

我们平时常见的分布式的配置变更，诸如：

- 线程池、线程池大小
- 开关、限流配置
- 数据源主备容灾切换
- 路由规则



###### 开源解决方案

1. disconf，百度开源，与spring集成的很好，有web管理，client只支持java。
2. diamond，阿里开源，阿里内部应用广泛，由http server（nameservers），diamond-server，web组成，diamond-server连接同一个mysql，数据同步通过mysql dump文件同步，支持订阅发布，client只支持java。
3. doozer，已停止更新，设计倾向于实时的数据变更通知，数据全部放于内存，不会持久化文件。
4. etcd，CoreOs开源，轻量级分布式key-value数据库，同时为集群环境的服务发现和注册而设计，它提供了数据TTL失效（通过TTL更新来判断机器下线，来避免一定的网络分区问题）、数据改变监视、多值、目录监听、分布式原子操作等功能，来管理节点状态。
5. zookeeper，成熟的分布式配置解决方案。



##### 分布式事务

​	分布式事务解决的是用户最本质诉求是什么？ **数据一致性**

数据不一致问题是必须解决的，在很多大企业多年前就已经成为突出问题，他们是怎么解决的？有这么几个典型方案：

- XA事务方案
- 柔性事务
- 基于消费的最终一致
- 业务补偿与人工订正



##### 分布式锁

分布式的CAP理论告诉我们，只能满足两项，我们需要作出取舍。

在互联网领域的绝大多数场景中，都需要牺牲强一致性来换取系统的高可用性，系统王王值需要保证“最终一致性”, 只要这个最终时间是在用户可以接受的范围内即可。

在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有时候我们需要保证一个方法在同一时间只能被同一个线程执行。



###### 常见的分布式锁的实现方案

- mysql
- 内存数据库（redis、memcached等）
- zookeeper



##### CAP权衡

按场景选择最合适的

对于涉及到钱财这样不能有一些让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CP。

对于其他场景，比较普通的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全。这其实是分布式领域的另一个理论



##### BASE理论

BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性，但应用可以采用合适的方式达到最终一致性。

BASE是指基本可用（Basically Available）、软转态（Soft State）、最终一致性（Eventual Consistency）。



###### 基本可用

基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。

比如电商大促时，为了应对访问量的激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失可用性的体现。



###### 软状态

软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。风不是存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现

。mysql replication的异步复制也是一种体现。



###### 最终一致性

最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一直性是弱一致性的特殊情况。



由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现出很多关于一致性的算法和协议：

1. 两阶段提交
2. 三阶段提交
3. Paxos算法
4. Zab协议



##### 分布式定时任务

首先，我们要了解计划任务这个概念，计划任务是指由计划的定时运行或者周期性运行的程序。我们最常见的就是Linux的crontab和windows的计划任务。

那么什么是分布式定时任务?  即把分散的，可靠性查的计划纳入统一的平台，并实现集群管理调度和分布式部署的一种定时任务的管理方式。



###### 分布式定时任务的优势：

1. 通过集群的方式进行管理调度，大大降低了开发成本和维护成本
2. 分布式部署，保证了系统的高可用性，收缩性，负载均衡，提高了容错
3. 可以通过控制台部署和管理任务，方便灵活高效
4. 任务都可以持久化到数据库，避免了宕机和数据丢失带来的隐患，同时有完善的任务失败重做机制和详细的任务跟踪及警告策略。
5. 

###### 流行的分布式定时任务框架

1. Quartz：Quartz是java领域最著名的开源任务调度工具，其提供了极为广泛的特性如持久化任务，集群和分布式任务
2. Elastic-job：Elastic-job是ddframe中dd-job的作业模块中分离出来的分布式弹性作业框架。去掉了和dd-job的监控和ddframe接入规范部分，该项目基于成熟开源产品Quartz和Zookeeper及其客户端Curator进行二次开发。



##### 分布式系统问题的本质

分布式各系统中间都需要进行网络通信，所以本来就在单一架构中能保证的数据一致性，升级为分布式系统后数据的一致性就难以保证，而Zookeeper的诞生就可以解决这个本质问题：数据一致性，再加上Zookeeper的其他特性还可以解决分布式锁，分布式定时任务等等场景问题。

