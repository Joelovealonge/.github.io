---
title: 计算机底层原理
tags:

  - Java并发
---



为什么要先来介绍计算机模型？

​	JVM是cpu+缓存+主存这样的一种抽象，是这样一种规范，屏蔽了不同计算机系列的底层。



## 计算机底层原理

现代计算机模型是基于-冯诺依曼计算机模型

![image-20200926105237246](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926105237246.png)

五大核心组成：控制器，运算器，存储器、输入、输出

现在计算机硬件结构原理图

![image-20200926105712006](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926105712006.png)

速度：寄存器>L1>L2>L3>内存条

控制内存可见性，就是一个Lock信号，就是Mesi缓存一致性协议，要求缓存强制性刷到内存中。



CPU内部结构

	- 控制单元
	- 运算单元
	- 内存单元

![image-20200926111411594](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926111411594.png)

CPU多核缓存架构

![image-20200926113205228](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926113205228.png)



**指令重排问题**：

​	为了使得处理器的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化，然后执行结果进行重组，保证该结果与顺序执行的结果是一致的，但并不保证程序各个语句计算的先后顺序和输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么顺序并不能靠代码的先后顺序来保证。Java虚拟机的即时编译器中也有类似的指令重排优化。

解决办法：

 1. 总线加锁

    CPU1在内存取数据的时候，先给总线加锁，CPU2就不能读写了（早期）。

    性能太低了，相当于串型

 2. 缓存一致性协议（MESI）

    

### 缓存一致性协议

有一部分缓存一致性协议解决不了，因为缓存一致性协议的工作机制，CPU缓存里面有一个最小存储单元-缓存行

MESI代表四种状态：

| 状态         | 描述                                                         | 监听任务                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| M 修改       | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行必须时刻监听所有试图读该缓存行相对于主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之后被延迟执行。 |
| E 独享、互斥 | 该Cache line有效，数据和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行业必须监听其他缓存读主存中该缓存的操作，一旦有这种操做，该缓存行需要变成S（共享）状态。 |
| S 共享       | 该Cache line有效，数据和内存中的数据不一致，数据存在于很多Cache中。 | 缓存行业必须监听其他缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效。 |
| I 无效       | 该Cache line无效。                                           | 无                                                           |

在java中加了volatile，实际上汇编中加了#Lock指令后，会触发缓存一致性协议机制。

假设cpu1 最先从主存中读x=1，读到cpu缓存中，与此同时该缓存行会变成一个独占（E）的状态，与此同时该cpu1会时刻监听其他cpu监听（总线嗅探）总线中对这一块内存的操作，假设该缓存还没有回显内存时，此时cpu2也将内存的x=1读到缓存中去，此时cpu1嗅探到cpu2读到缓存中，此时cpu会更改该缓存为共享状态（S），cpu1把x=1读到寄存器中，然后计算后得到x=2，cpu1将x=2回写内存的时候，锁住该缓存行即M的状态，向总线里面发一个消息，其他人读到这个消息，cpu2会把自己的这个缓存行变成无效（I），cpu1写完内存后，于此同时cpu1缓存中变成独占（E）状态，然后cpu2就去主存中重新读了。

如果两个cpu同时进行x状态的修改怎么办？一个指令周期内，会进行裁决。



缓存一致性只是解决了可见性问题。



什么情况下缓存一致性会失效？

1. 如果说x存储长度大于一个缓存行，一个缓存行大小有可能会是32字节、64字节或者是128字节。这种情况下会使用总线加锁。

 	2. 你的计算机不支持缓存一致性协议。



## 线程

进程是系统分配资源的基本单位，线程是调度Cpu的基本单位，一个进程只是包含一个执行线程，线程寄生在进程当中。每个线程都有一个程序计数器（记录执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。

线程分为两类：

1. 用户级线程
2. 内核级线程

![image-20200926141328354](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926141328354.png)

ULT会发生线程阻塞

​	用户进程，创建多个ULT线程，但是只能分配到一个cpu，当cpu时间片执行完线程1，然后执行线程2的时候发生了阻塞，后面的线程3，线程4也就没法执行。

![image-20200926143337135](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926143337135.png)



JVM采用的是1.2版本之前用的是ULT、1，2版本之后用的是KLT

Java线程与内核线程的关系：一比一对应

![image-20200926141653928](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926141653928.png)

这样java线程才有了竞争CPU的使用权限



用户空间划分：

1. 内核空间
2. 用户空间

![image-20200926140610232](https://cdn.jsdelivr.net/gh/joelovealonge/noteimgs/image-20200926140610232.png)